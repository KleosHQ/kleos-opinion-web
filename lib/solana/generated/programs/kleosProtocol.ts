/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertIsInstructionWithAccounts,
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type Instruction,
  type InstructionWithData,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  parseClaimPayoutInstruction,
  parseClaimPayoutNativeInstruction,
  parseCloseMarketInstruction,
  parseCreateMarketInstruction,
  parseCreateMarketNativeInstruction,
  parseEditMarketInstruction,
  parseInitializeProtocolInstruction,
  parseOpenMarketInstruction,
  parsePlacePositionInstruction,
  parsePlacePositionNativeInstruction,
  parseSettleMarketInstruction,
  parseSettleMarketNativeInstruction,
  parseUpdateProtocolInstruction,
  type ParsedClaimPayoutInstruction,
  type ParsedClaimPayoutNativeInstruction,
  type ParsedCloseMarketInstruction,
  type ParsedCreateMarketInstruction,
  type ParsedCreateMarketNativeInstruction,
  type ParsedEditMarketInstruction,
  type ParsedInitializeProtocolInstruction,
  type ParsedOpenMarketInstruction,
  type ParsedPlacePositionInstruction,
  type ParsedPlacePositionNativeInstruction,
  type ParsedSettleMarketInstruction,
  type ParsedSettleMarketNativeInstruction,
  type ParsedUpdateProtocolInstruction,
} from "../instructions";

export const KLEOS_PROTOCOL_PROGRAM_ADDRESS =
  "6jmg3EdNVE2PgLJHkzzGxG8aqsKWxLKvrgDjszTreAhD" as Address<"6jmg3EdNVE2PgLJHkzzGxG8aqsKWxLKvrgDjszTreAhD">;

export enum KleosProtocolAccount {
  Market,
  Position,
  Protocol,
}

export function identifyKleosProtocolAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): KleosProtocolAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([219, 190, 213, 55, 0, 227, 198, 154]),
      ),
      0,
    )
  ) {
    return KleosProtocolAccount.Market;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([170, 188, 143, 228, 122, 64, 247, 208]),
      ),
      0,
    )
  ) {
    return KleosProtocolAccount.Position;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([45, 39, 101, 43, 115, 72, 131, 40]),
      ),
      0,
    )
  ) {
    return KleosProtocolAccount.Protocol;
  }
  throw new Error(
    "The provided account could not be identified as a kleosProtocol account.",
  );
}

export enum KleosProtocolInstruction {
  ClaimPayout,
  ClaimPayoutNative,
  CloseMarket,
  CreateMarket,
  CreateMarketNative,
  EditMarket,
  InitializeProtocol,
  OpenMarket,
  PlacePosition,
  PlacePositionNative,
  SettleMarket,
  SettleMarketNative,
  UpdateProtocol,
}

export function identifyKleosProtocolInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): KleosProtocolInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([127, 240, 132, 62, 227, 198, 146, 133]),
      ),
      0,
    )
  ) {
    return KleosProtocolInstruction.ClaimPayout;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([150, 118, 110, 108, 112, 229, 145, 174]),
      ),
      0,
    )
  ) {
    return KleosProtocolInstruction.ClaimPayoutNative;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([88, 154, 248, 186, 48, 14, 123, 244]),
      ),
      0,
    )
  ) {
    return KleosProtocolInstruction.CloseMarket;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([103, 226, 97, 235, 200, 188, 251, 254]),
      ),
      0,
    )
  ) {
    return KleosProtocolInstruction.CreateMarket;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([35, 110, 189, 223, 219, 138, 49, 141]),
      ),
      0,
    )
  ) {
    return KleosProtocolInstruction.CreateMarketNative;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([77, 92, 29, 5, 217, 159, 214, 32]),
      ),
      0,
    )
  ) {
    return KleosProtocolInstruction.EditMarket;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([188, 233, 252, 106, 134, 146, 202, 91]),
      ),
      0,
    )
  ) {
    return KleosProtocolInstruction.InitializeProtocol;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([116, 19, 123, 75, 217, 244, 69, 44]),
      ),
      0,
    )
  ) {
    return KleosProtocolInstruction.OpenMarket;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([218, 31, 90, 75, 101, 209, 5, 253]),
      ),
      0,
    )
  ) {
    return KleosProtocolInstruction.PlacePosition;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([118, 20, 49, 30, 199, 227, 113, 107]),
      ),
      0,
    )
  ) {
    return KleosProtocolInstruction.PlacePositionNative;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([193, 153, 95, 216, 166, 6, 144, 217]),
      ),
      0,
    )
  ) {
    return KleosProtocolInstruction.SettleMarket;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([24, 173, 149, 74, 233, 65, 24, 146]),
      ),
      0,
    )
  ) {
    return KleosProtocolInstruction.SettleMarketNative;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([206, 25, 218, 114, 109, 41, 74, 173]),
      ),
      0,
    )
  ) {
    return KleosProtocolInstruction.UpdateProtocol;
  }
  throw new Error(
    "The provided instruction could not be identified as a kleosProtocol instruction.",
  );
}

export type ParsedKleosProtocolInstruction<
  TProgram extends string = "6jmg3EdNVE2PgLJHkzzGxG8aqsKWxLKvrgDjszTreAhD",
> =
  | ({
      instructionType: KleosProtocolInstruction.ClaimPayout;
    } & ParsedClaimPayoutInstruction<TProgram>)
  | ({
      instructionType: KleosProtocolInstruction.ClaimPayoutNative;
    } & ParsedClaimPayoutNativeInstruction<TProgram>)
  | ({
      instructionType: KleosProtocolInstruction.CloseMarket;
    } & ParsedCloseMarketInstruction<TProgram>)
  | ({
      instructionType: KleosProtocolInstruction.CreateMarket;
    } & ParsedCreateMarketInstruction<TProgram>)
  | ({
      instructionType: KleosProtocolInstruction.CreateMarketNative;
    } & ParsedCreateMarketNativeInstruction<TProgram>)
  | ({
      instructionType: KleosProtocolInstruction.EditMarket;
    } & ParsedEditMarketInstruction<TProgram>)
  | ({
      instructionType: KleosProtocolInstruction.InitializeProtocol;
    } & ParsedInitializeProtocolInstruction<TProgram>)
  | ({
      instructionType: KleosProtocolInstruction.OpenMarket;
    } & ParsedOpenMarketInstruction<TProgram>)
  | ({
      instructionType: KleosProtocolInstruction.PlacePosition;
    } & ParsedPlacePositionInstruction<TProgram>)
  | ({
      instructionType: KleosProtocolInstruction.PlacePositionNative;
    } & ParsedPlacePositionNativeInstruction<TProgram>)
  | ({
      instructionType: KleosProtocolInstruction.SettleMarket;
    } & ParsedSettleMarketInstruction<TProgram>)
  | ({
      instructionType: KleosProtocolInstruction.SettleMarketNative;
    } & ParsedSettleMarketNativeInstruction<TProgram>)
  | ({
      instructionType: KleosProtocolInstruction.UpdateProtocol;
    } & ParsedUpdateProtocolInstruction<TProgram>);

export function parseKleosProtocolInstruction<TProgram extends string>(
  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedKleosProtocolInstruction<TProgram> {
  const instructionType = identifyKleosProtocolInstruction(instruction);
  switch (instructionType) {
    case KleosProtocolInstruction.ClaimPayout: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: KleosProtocolInstruction.ClaimPayout,
        ...parseClaimPayoutInstruction(instruction),
      };
    }
    case KleosProtocolInstruction.ClaimPayoutNative: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: KleosProtocolInstruction.ClaimPayoutNative,
        ...parseClaimPayoutNativeInstruction(instruction),
      };
    }
    case KleosProtocolInstruction.CloseMarket: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: KleosProtocolInstruction.CloseMarket,
        ...parseCloseMarketInstruction(instruction),
      };
    }
    case KleosProtocolInstruction.CreateMarket: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: KleosProtocolInstruction.CreateMarket,
        ...parseCreateMarketInstruction(instruction),
      };
    }
    case KleosProtocolInstruction.CreateMarketNative: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: KleosProtocolInstruction.CreateMarketNative,
        ...parseCreateMarketNativeInstruction(instruction),
      };
    }
    case KleosProtocolInstruction.EditMarket: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: KleosProtocolInstruction.EditMarket,
        ...parseEditMarketInstruction(instruction),
      };
    }
    case KleosProtocolInstruction.InitializeProtocol: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: KleosProtocolInstruction.InitializeProtocol,
        ...parseInitializeProtocolInstruction(instruction),
      };
    }
    case KleosProtocolInstruction.OpenMarket: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: KleosProtocolInstruction.OpenMarket,
        ...parseOpenMarketInstruction(instruction),
      };
    }
    case KleosProtocolInstruction.PlacePosition: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: KleosProtocolInstruction.PlacePosition,
        ...parsePlacePositionInstruction(instruction),
      };
    }
    case KleosProtocolInstruction.PlacePositionNative: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: KleosProtocolInstruction.PlacePositionNative,
        ...parsePlacePositionNativeInstruction(instruction),
      };
    }
    case KleosProtocolInstruction.SettleMarket: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: KleosProtocolInstruction.SettleMarket,
        ...parseSettleMarketInstruction(instruction),
      };
    }
    case KleosProtocolInstruction.SettleMarketNative: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: KleosProtocolInstruction.SettleMarketNative,
        ...parseSettleMarketNativeInstruction(instruction),
      };
    }
    case KleosProtocolInstruction.UpdateProtocol: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: KleosProtocolInstruction.UpdateProtocol,
        ...parseUpdateProtocolInstruction(instruction),
      };
    }
    default:
      throw new Error(
        `Unrecognized instruction type: ${instructionType as string}`,
      );
  }
}
